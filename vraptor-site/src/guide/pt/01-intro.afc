[chapter VRaptor3]

O VRaptor 3 foca em simplicidade e, portanto, todas as funcionalidades que você verá 
tem como primeira meta resolver o problema do programador da maneira menos intrusiva possível
em seu código.

Sejam as clássicas lógicas de adicionar, remover, buscar e atualizar ou ainda
funcionalidades que costumam ser mais complexas como upload e download de arquivos,
resultados diferentes para formatos diferentes (xml, json, xhtml etc), tudo isso
é feito através de funcionalidades simples do vraptor 3. 

Essa documentação inclui, portanto, exemplos de tarefas que não são as triviais, para tentar mostrar ao usuário que até mesmo o que fica fora
do padrão crud trivial também é de simples implementação usando o vraptor3.

Claro, as funcionalidades simples ainda são fáceis de implementar, mas vemos ver
dois exemplos clássicos que outros controladores não implementam de maneira tão simples
assim.


[section Um exemplo de create básico]

Agora que já passamos pelos exemplos que devem demonstrar a simplicidade
que o VRaptor permite que os programadores escrevam seu código mesmo em situações
não triviais, vejamos um exemplo de inserção de dados:

[code]
@Resource
public class PerfilController {

	private final PerfilDao dao;

	public PerfilController(PerfilDao dao) {
		this.dao = dao;
	}

	public void adiciona(Perfil novoPerfil) {
		dao.adiciona(novoPerfil);
	}
}
[/code]

Pronto. O VRaptor será capaz de, atraves de seu container de Injecao de Dependencias,
passar o PerfilDao para seu construtor, e invocar o metodo adiciona com os parametros
adequados de acordo com a requisicao.

Se os parametros do request forem "novoPerfil.nome", "novoPerfil.usuario" e "novoPerfil.senha", os
setters da variavel novoPerfil serão invocados.

<Importante> notar que o vraptor utiliza o paranamer para descobrir os nomes de seus
parâmetros (no exemplo, novoPerfil) - diferente de outras ferramentas, com o VRaptor
você <<não>> precisa anotar suas variaveis de parametros, que ficariam extremamente poluídos.

[section REST]

Seguindo a idéia de que URIs devem identificar recursos na rede para então podermos
fazer valer as diversas vantagens estruturais que o padrão http nos proporciona, 
note o quão simples fica mapear diversos métodos http para a mesma uri. Novamente
<<nenhuma>> anotação foi necessária para os parametros.

[code]
@Resource
public class PerfilController {

	// ...

	@Post
	@Path("/perfil")
	public void adiciona(Perfil novoPerfil) {
		dao.adiciona(novoPerfil);
	}
	
	@Get
	@Path("/perfil")
	public List<Perfil> lista() {
		return dao.lista();
	}
	
	@Get
	@Path("/perfil/{perfil.id}")
	public Perfil visualiza(Perfil perfil) {
		return dao.busca(perfil);
	}
	
	@Delete
	@Path("/perfil/{perfil.id}")
	public void remove(Perfil perfil) {
		dao.remove(perfil);
	}
	
	@Put
	@Path("/perfil/{perfil.id}")
	public void atualiza(Perfil perfil) {
		dao.atualiza(perfil);
	}
	
}
[/code]

Isto é, cada método (exceto o adiciona) está mapeado para diferentes requisições
http para o mesmo recurso. Para o perfil de id=3, basta acessar a uri /perfil/3.

<Note> também o retorno do método <visualiza>, que automaticamente disponibiliza
uma variável chamada <perfil> para sua camada de view (jsp, freemarker etc). 

[section Meus jsps]

Após a invocação do método visualiza do seu PerfilController, o arquivo <WEB-INF/jsp/perfil/visualiza.jsp>
é automaticamente invocado, já disponibilizando o perfil retornado pelo método!

O redirecionamento também é algo inovador e sem configuração em arquivos externos.
Imagine que após a remoção desejamos redirecionar para a listagem:

[code]
		dao.remove(perfil);
		result.use(logic()).redirectTo(PerfilController.class).lista();
[/code]

Isto é, estamos dizendo que desejamos ir como resultado para a lógica lista.
O VRaptor resolve a uri que deve ser enviada para o cliente fazer o client-side-redirect.
Se por algum acaso você mudar a uri de mapeamento da lógica de listagem, o redirect
continua funcionando!

[section Validação]

on error goto form

[section E agora?]

link para download dos arquivos
link para vraptor-example
