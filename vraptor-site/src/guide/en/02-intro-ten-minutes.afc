[chapter VRaptor3 - Ten minutes guide]

[section Starting a project: a on-line store]
Let's start by downloading the ::vraptor-blank-project:: from http://vraptor.caelum.com.br/download.html.
This blank-project has the required configuration on web.xml and the dependencies on WEB-INF/lib that is
needed to start using VRaptor. You can also import this project on Eclipse.

We need to change the base package on this config at web.xml:
[xml h=3]
<context-param>
    <param-name>br.com.caelum.vraptor.packages</param-name>
    <param-value>com.companyname.projectname</param-value>
</context-param>
[/xml]

All classes from your application **must** be in a child package of %%com.companyname.projectname%%,
so VRaptor can find your components and manage your dependencies. In this example project the base
package will be:

[xml h=3]
<context-param>
    <param-name>br.com.caelum.vraptor.packages</param-name>
    <param-value>br.com.caelum.onlinestore</param-value>
</context-param>
[/xml]

Assuming that the context root of the application was changed to %%/onlinestore%%, if you run
this example you should be able to access %%http://localhost:8080/onlinestore%% and see
an **It works!** on screen.

[section Product registry]
Let's start the system with a products registry. We need a class that will represent the products,
and we'll use it to persist products on the database, with Hibernate:

[java]
@Entity
public class Product {
	@Id
	@GeneratedValue
	public Long id;
	
	public String name;
	public String description;
	public Double price;
	//getter and setters
}
[/java]

We need also a class that will ::control:: the registry of products, handling web requests.
This class will be the Products %%Controller%%:

[java]
public class ProductsController {
}
[/java]

ProductsController will expose URIs to be accessed through web, i.e, will expose resources of your
application. And for indicate it, you must annotate it with %%@Resource%%:

[java h=1]
@Resource
public class ProductsController {
}
[/java]

By using this annotation, all public methods of the annotated class will be reachable through web.
For instance, if there is a %%list%% method on the class:

[java h=1]
@Resource
public class ProductsController {
	public List<Product> list() {
		return new ArrayList<Product>();
	}
}
[/java]

than VRaptor will automatically redirect all requests to the URI %%/products/list%% to this method.
The convention for URIs is: %%/<controller_name>/<method_name>%%.

At the end of method execution, VRaptor will %%dispatch%% the request to the jsp at
%%/WEB-INF/jsp/products/list.jsp%%. The convention for the default view is
%%/WEB-INF/jsp/<controller_name>/<method_name>.jsp%%.

The %%list%% method will return a product list, so how can I get it on jsp? On VRaptor, 
the method return value will be exported to the jsp by request attributes. In this case,
the name of the exported attribute will be %%productList%%, holding the method returned value:

list.jsp
[xml]
<ul>
<c:forEach items="${productList}" var="product">
	<li> ${product.name} - ${product.description} </li>
</c:forEach>
</ul>
[/xml]

The convention for the attribute names is pretty intuitive: if it is a collection, as it is the case,
the name will be %%<collection_type>List%%; if it is any other type, the name will be the class name
with the first letter in lowercase, i.e, if the type is %%Product%%, the name will be %%product%%.

[section Creating ProductDao: Dependency Injection]
VRaptor widely use the Dependency Injection and Inversion of Control concept.
The whole idea is simple: if you need a resource, you won't create it, 
it will be given to you when you ask for it. You can get more information about it
on the Dependency Injection chapter.

We are returning a hard coded empty list on our list method. It would be more helpful if we
return a real list, for example all of registered products of the system. In order to do that,
let's create a product Dao, for listing the products:

[java]
public class ProductDao {

	public List<Product> listAll() {
		return new ArrayList<Product>();
	}
	
}
[/java]

And in the ProductsController we might use the dao for listing products:

[java]
@Resource
public class ProductsController {
	
	private ProductDao dao;
	
	public List<Product> list() {
		return dao.listAll();
	}
	
}
[/java]

We could create a new ProductDao inside the controller, but we can simply loose coupling by
receiving it on the class constructor, and letting VRaptor do its Dependency Management Magic
and provide an instance of ProductDao when creating our controller! And for enabling this
behavior we only have to annotate the ProductDao class with @Component:

[java h=1,11,12,13]
@Component
public class ProductDao {
	//...
}

@Resource
public class ProductsController {
	
	private ProductDao dao;

	public ProductsController(ProductDao dao) {
		this.dao = dao;
	}
		
	public List<Product> list() {
		return dao.listAll();
	}
	
}
[/java]

[section Add form: redirecting the request]
We have a Products listing, but no way to register products. Thus let's create a
form for adding products. Since it is not a good idea to access the jsps directly,
let's create an empty method that only redirects to a jsp:

[java]
@Resource
public class ProductsController {
	//...
	public void form() {
	}
}
[/java]

So we can access the form by URI %%/products/form%%, and the form will be at
%%/WEB-INF/jsp/products/form.jsp%%:
[xml]
<form action="<c:url value="/products/adiciona"/>">
	Name: 			<input type="text" name="product.name" /><br/>
	Description:<input type="text" name="product.description" /><br/>
	Price:			<input type="text" name="product.price" /><br/>
	<input type="submit" value="Save" />
</form>
[/xml]

This form will save a product using the URI %%/products/add%%, so we must create
this method on the controller:

[java]
@Resource
public class ProductsController {
	//...
	public void add() {
	}
}
[/java]

Look at the input names: **product.name**, **product.description** and **product.price**.
If we receive a %%Product%% named %%product%% as parameter on add method, VRaptor will 
set the fields **name**, **description** and **price** with the input values, using
the corresponding setters on Product. The **product.price** parameter will also be converted
into Double before being set on the product. More information on Converters chapter.

Thus, having the correct names on the form inputs, we can create the add method:
[java]
@Resource
public class ProductsController {
	//...
	public void add(Product product) {
		dao.save(product);
	}
}
[/java]


Right after saving something on a form we usually want to be redirected to the listing
or back to the form. In this case we want to be redirected to the products listing.
For this purpose there is a VRaptor component: the %%Result%%. It is responsible for 
adding attributes on the request, and for dispatching to a different view. To get a Result
instance you must receive it as a constructor parameter:

[java]
@Resource
public class ProductsController {
	public ProductsController(ProductDao dao, Result result) {
		this.dao = dao;
		this.result = result;
	}
}
[/java]
In order to redirect to the listing, you can use the result object:

[java]
	result.use(Results.logic()).redirectTo(ProductsController.class).list();
[/java]

This code snippet can be read as: ::As a result, use a logic, redirecting to the 
list method in ProductsController::. All redirect configuration is 100% java code, 
with no strings involved! It's clear from the code that the result from your logic
is not the default, and which one you're using. There is no need to worry about 
configuration files. Furthermore, if you need to rename the %%list%% method, there
is no need to go through your entire application looking for redirects to this method,
just use your usual refactoring IDE to do the rename.

Então nosso método %%adiciona%% ficaria:
[java]
	public void adiciona(Product product) {
		dao.adiciona(product);
		result.use(Results.logic()).redirectTo(ProductsController.class).lista();
	}
[/java]

Mais informações sobre o Result no capítulo Views e Ajax.

[section Validação]
Não faz muito sentido adicionar um product sem nome no sistema, nem um product com preço negativo.
Antes de adicionar o product, precisamos verificar se é um product válido, com nome e preço positivo,
e caso não seja válido voltamos para o formulário com mensagens de erro. Para fazermos isso, podemos
usar um componente do VRaptor: o Validator. Você pode recebê-lo no construtor do seu Controller, e
usá-lo da seguinte maneira:
[java h=9,10,11,12,13]
@Resource
public class ProductsController {
	public ProductsController(ProductDao dao, Result result, Validator validator) {
		//...
		this.validator = validator;
	}
	
	public void adiciona(Product product) {
		validator.checking(new Validations() {{
			that(!product.getNome().isEmpty(), "product.nome", "nome.vazio");
			that(product.getPreco() > 0, "product.nome", "preco.invalido");
		}});
		validator.onErrorUse(Results.page()).of(ProductsController.class).form();
		
		dao.adiciona(product);
		result.use(Results.logic()).redirectTo(ProductsController.class).lista();
	}
}
[/java]

Podemos ler as validações da seguinte maneira: ::Valide que o nome do product não é vazio e
que o preço do product é maior que zero. Se acontecer um erro, use como resultado a página
do form do ProductsController::. Ou seja, se por exemplo o nome do product for vazio, vai
ser adicionada a mensagem de erro para o campo "product.nome", com a mensagem "nome.vazio"
internacionalizada. Se acontecer algum erro, o sistema vai voltar pra página do formulário,
com os campos preenchidos e com mensagens de erro que podem ser acessadas da seguinte maneira:

[xml]
<c:forEach var="error" items="${errors}">
	${error.category}  ${error.message}<br />
</c:forEach>
[/xml]

Mais informações sobre o Validator no capítulo de Validações.

Com o que foi visto até agora você já consegue fazer 90% da sua aplicação! As próximas sessões
desse tutorial mostram a solução para alguns problemas frequentes que estão nos outros 10% da
sua aplicação.

[section Usando o Hibernate para guardar os Products]

Agora vamos fazer uma implementação de verdade do ProductDao, usando o Hibernate para
persistir os products. Para isso nosso ProductDao precisa de uma Session. Como o VRaptor
usa injeção de dependências, basta receber uma Session no construtor!

[java]
@Component
public class ProductDao {
	
	private Session session;
	
	public ProductDao(Session session) {
		this.session = session;
	}

	public void adiciona(Product product) {
		session.save(product);
	}
	//...
}
[/java]

Mas peraí, para o VRaptor precisa saber como criar essa Session, e eu não posso simplesmente
colocar um @Component na Session pois é uma classe do Hibernate! Para isso existe a interface
ComponentFactory, que você pode usar pra criar uma Session. Mais informações de como fazer
ComponentFactories no capítulo de Componentes. Você pode ainda usar os ComponentFactories que
já estão disponíveis para isso no VRaptor, como mostra o capítulo de Utils.

[section Controlando transações: Interceptors]
Muitas vezes queremos interceptar todas as requisições (ou uma parte delas) e executar alguma
lógica, como acontece com o controle de transações. Para isso existem os Interceptor's no
VRaptor. Saiba mais sobre eles no capítulo de Interceptors. Existe um TransactionInterceptor
já implementado no VRaptor, saiba como usá-lo no capítulo de Utils.

[section Carrinho de compras: Componentes na sessão]
Se quisermos criar um carrinho de compras no nosso sistema, precisamos de alguma forma manter os
itens do carrinho na Sessão do usuário. Para fazer isso, podemos criar um componente que está no
escopo de sessão, ou seja, ele vai ser único na sessão do usuário. Para isso basta criar um
componente anotado com @SessionScoped:
[java]
@Component
@SessionScoped
public class CarrinhoDeCompras {
	private List<Product> itens = new ArrayList<Product>();
	
	public List<Product> getTodosOsItens() {
		return itens;
	}
	
	public void adicionaItem(Product item) {
		itens.add(item);
	}
}
[/java]

Como esse carrinho de compras é um componente, podemos recebê-lo no construtor do controller que
vai cuidar do carrinho de compras:

[java]
@Resource
public class CarrinhoController {

	public CarrinhoController(CarrinhoDeCompras carrinho) {
		this.carrinho = carrinho;
	}

	public void adiciona(Product product) {
		carrinho.adicionaItem(product);
	}
	
	public List<Product> listaItens() {
		return carrinho.getTodosOsItens();
	}
}
[/java]

Além do escopo de sessão existe o escopo de Aplicação com a anotação @ApplicationScoped.
Os componentes anotados com @ApplicationScoped serão criados apenas uma vez em toda a aplicação. 

[section Um pouco de REST]

Seguindo a idéia REST de que %%URI%%s devem identificar recursos na rede para então podermos
fazer valer as diversas vantagens estruturais que o protocolo HTTP nos proporciona, 
note o quão simples fica mapear os diversos métodos HTTP para a mesma URI, e com
isso invocar diferentes métodos, por exemplo queremos usar as seguintes URIs para o
cadastro de products:

[code]
	GET /products - lista todos os products
	POST /products - adiciona um product
	GET /products/{id} - visualiza o product com o id passado
	PUT /products/{id} - atualiza as informações do product com o id passado
	DELETE /products/{id} - remove o product com o id passado
[/code]

Para criar esse comportamento REST no VRaptor podemos usar as anotações @Path
- que muda qual é a uri que vai acessar o determinado método, e as anotações
com os nomes dos métodos HTTP @Get, @Post, @Delete, @Put, que indicam que o método
anotado só pode ser acessado se a requisição estiver com o método HTTP indicado.
Então uma versão REST do nosso ProductsController seria:

[java]
public class ProductsController {
	//...
	
	@Get
	@Path("/products")
	public List<Product> lista() {...}
	
	@Post
	@Path("/products")
	public void adiciona(Product product) {...}

	@Get
	@Path("/products/{product.id}")
	public void visualiza(Product product) {...}
	
	@Put
	@Path("/products/{product.id}")
	public void atualiza(Product product) {...}
	
	@Delete
	@Path("/products/{product.id}")
	public void remove(Product product) {...}
	
}
[/java]

Note que podemos receber parâmetros nas URIs. Por exemplo se chamarmos a URI
**GET /products/5**, o método visualiza será invocado, e o parâmetro product vai
ter o id populado com 5.

Mais informações sobre isso no capítulo de Resources-REST.

[section Message bundle File]

Internationalization (i18n) is a powerful feature present in almost all Web frameworks 
nowadays. And it’s no different with VRaptor3. With i18n you can make your applications 
support several different languages (such as French, Portuguese, Spanish, English, etc) 
in a very easy way: simply translating the application messages.

In order to support i18n, you must create a file called %%messages.properties%% and make 
it available in your application classpath (%%WEB-INF/classes%%). That file contains 
lines which are a set of key/value entries, for example:

[code properties]
	field.userName = Username 
	field.password = Password
[/code]

So far, it’s easy, but what if you want to create files containing messages in other 
languages, for example, Portuguese? Also easy. You just need to create another properties 
file called %%messages_pt_BR.properties%%. Notice the suffix ::_pt_BR:: on the file name. 
It indicates that when the user access your application from his computer configured with 
Brazilian Portuguese locale, the messages in this file will be used. The file contents 
would be:

[code properties]
field.userName = Nome do Usuário
field.password = Senha
[/code]

Notice that the keys are the same in both files, what changes is the value to the specific 
language.

In order to use those messages in your JSP files, you could use JSTL. The code would go 
as follows:

[code]
<html> 
	<body> 
		<fmt:message key="field.userName" /> <input name="user.userName" /> 
         
		<br /> 
		
		<fmt:message key="field.password" /> <input type="password" name="user.password" /> 
		
		<input type="submit" /> 
	</body> 
</html>
[/code]
