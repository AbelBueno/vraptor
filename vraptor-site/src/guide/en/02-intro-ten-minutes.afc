[chapter VRaptor3 - Ten minutes guide]

[section Starting a project: a on-line store]
Let's start by downloading the ::vraptor-blank-project:: from http://vraptor.caelum.com.br/download.html.
This blank-project has the required configuration on web.xml and the dependencies on WEB-INF/lib that is
needed to start using VRaptor. You can also import this project on Eclipse.

We need to change the base package on this config at web.xml:
[xml h=3]
<context-param>
    <param-name>br.com.caelum.vraptor.packages</param-name>
    <param-value>com.companyname.projectname</param-value>
</context-param>
[/xml]

All classes from your application **must** be in a child package of %%com.companyname.projectname%%,
so VRaptor can find your components and manage your dependencies. In this example project the base
package will be:

[xml h=3]
<context-param>
    <param-name>br.com.caelum.vraptor.packages</param-name>
    <param-value>br.com.caelum.onlinestore</param-value>
</context-param>
[/xml]

Assuming that the context root of the application was changed to %%/onlinestore%%, if you run
this example you should be able to access %%http://localhost:8080/onlinestore%% and see
an **It works!** on screen.

[section Product registry]
Let's start the system with a products registry. We need a class that will represent the products,
and we'll use it to persist products on the database, with Hibernate:

[java]
@Entity
public class Product {
	@Id
	@GeneratedValue
	public Long id;
	
	public String name;
	public String description;
	public Double price;
	//getter and setters
}
[/java]

We need also a class that will ::control:: the registry of products, handling web requests.
This class will be the Products %%Controller%%:

[java]
public class ProductsController {
}
[/java]

ProductsController will expose URIs to be accessed through web, i.e, will expose resources of your
application. And for indicate it, you must annotate it with %%@Resource%%:

[java h=1]
@Resource
public class ProductsController {
}
[/java]

By using this annotation, all public methods of the annotated class will be reachable through web.
For instance, if there is a %%list%% method on the class:

[java h=1]
@Resource
public class ProductsController {
	public List<Product> list() {
		return new ArrayList<Product>();
	}
}
[/java]

than VRaptor will automatically redirect all requests to the URI %%/products/list%% to this method.
The convention for URIs is: %%/<controller_name>/<method_name>%%.

At the end of method execution, VRaptor will %%dispatch%% the request to the jsp at
%%/WEB-INF/jsp/products/list.jsp%%. The convention for the default view is
%%/WEB-INF/jsp/<controller_name>/<method_name>.jsp%%.

The %%list%% method will return a product list, so how can I get it on jsp? On VRaptor, 
the method return value will be exported to the jsp by request attributes. In this case,
the name of the exported attribute will be %%productList%%, holding the method returned value:

list.jsp
[xml]
<ul>
<c:forEach items="${productList}" var="product">
	<li> ${product.name} - ${product.description} </li>
</c:forEach>
</ul>
[/xml]

The convention for the attribute names is pretty intuitive: if it is a collection, as it is the case,
the name will be %%<collection_type>List%%; if it is any other type, the name will be the class name
with the first letter in lowercase, i.e, if the type is %%Product%%, the name will be %%product%%.

[section Creating ProductDao: Dependency Injection]
VRaptor widely use the Dependency Injection and Inversion of Control concept.
The whole idea is simple: if you need a resource, you won't create it, 
it will be given to you when you ask for it. You can get more information about it
on the Dependency Injection chapter.

We are returning a hard coded empty list on our list method. It would be more helpful if we
return a real list, for example all of registered products of the system. In order to do that,
let's create a product Dao, for listing the products:

[java]
public class ProductDao {

	public List<Product> listAll() {
		return new ArrayList<Product>();
	}
	
}
[/java]

And in the ProductsController we might use the dao for listing products:

[java]
@Resource
public class ProductsController {
	
	private ProductDao dao;
	
	public List<Product> list() {
		return dao.listAll();
	}
	
}
[/java]

We could create a new ProductDao inside the controller, but we can simply loose coupling by
receiving it on the class constructor, and letting VRaptor do its Dependency Management Magic
and provide an instance of ProductDao when creating our controller! And for enabling this
behavior we only have to annotate the ProductDao class with @Component:

[java h=1,11,12,13]
@Component
public class ProductDao {
	//...
}

@Resource
public class ProductsController {
	
	private ProductDao dao;

	public ProductsController(ProductDao dao) {
		this.dao = dao;
	}
		
	public List<Product> list() {
		return dao.listAll();
	}
	
}
[/java]

[section Add form: redirecting the request]
Temos uma listagem de Products, mas ainda não temos como cadastrá-los. Vamos então criar
um formulário de adição de products. Para não ter que acessar o jsp diretamente, vamos
criar uma lógica vazia que só redireciona pro jsp:

[java]
@Resource
public class ProductsController {
	//...
	public void form() {
	}
}
[/java]

Podemos acessar o formulário pela URI %%/products/form%%, e o formulário estará em
%%/WEB-INF/jsp/products/form.jsp%%:
[xml]
<form action="<c:url value="/products/adiciona"/>">
	Nome: 			<input type="text" name="product.nome" /><br/>
	Descrição:	<input type="text" name="product.descricao" /><br/>
	Preço:			<input type="text" name="product.preco" /><br/>
	<input type="submit" value="Salvar" />
</form>
[/xml]

O formulário vai salvar o Product pela URI %%/products/adiciona%%, então precisamos criar
esse método no nosso controller:

[java]
@Resource
public class ProductsController {
	//...
	public void adiciona() {
	}
}
[/java]

Repare nos nomes dos nossos inputs: **product.nome**, **product.descricao** e **product.preco**.
Se recebermos um %%Product%% no método %%adiciona%% com o nome **product**, o VRaptor vai popular
os seus campos **nome**, **descricao** e **preco**, usando os seus setters no Product, 
com os valores digitados nos inputs. Inclusive o campo **preco**, vai ser convertido para Double
antes de ser setado no product. Veja mais sobre isso no capítulo de converters.

Então, usando os nomes corretamente nos inputs do form, basta criar seu método adiciona:
[java]
@Resource
public class ProductsController {
	//...
	public void adiciona(Product product) {
		dao.adiciona(product);
	}
}
[/java]

Geralmente depois de adicionar algo no sistema queremos voltar para a sua listagem, ou para o
formulário novamente. No nosso caso, queremos voltar pra listagem de products ao adicionar um
product novo. Para isso existe um componente do VRaptor: o **%%Result%%**. Ele é responsável por
adicionar atributos na requisição, e por mudar a view a ser carregada. Se eu quiser uma instância
de Result, basta recebê-lo no construtor:
[java]
@Resource
public class ProductsController {
	public ProductsController(ProductDao dao, Result result) {
		this.dao = dao;
		this.result = result;
	}
}
[/java]
E para redirecionar para a listagem basta usar o result:
[java]
	result.use(Results.logic()).redirectTo(ProductsController.class).lista();
[/java]

Podemos ler esse código como: ::Como resultado, use uma lógica, redirecionando para o
método lista do ProductsController::. A configuração de redirecionamento é 100% java,
sem strings envolvidas! Fica explícito no seu código que o resultado da sua lógica não
é o padrão, e qual resultado você está usando! Você não precisa ficar se preocupando com
arquivos de configuração! Mais ainda, se eu quiser mudar o nome do método %%lista%%, eu não preciso
ficar rodando o sistema inteiro procurando onde estão redirecionando pra esse método, basta
usar o refactor do eclipse, por exemplo, e tudo continua funcionando!

Então nosso método %%adiciona%% ficaria:
[java]
	public void adiciona(Product product) {
		dao.adiciona(product);
		result.use(Results.logic()).redirectTo(ProductsController.class).lista();
	}
[/java]

Mais informações sobre o Result no capítulo Views e Ajax.

[section Validação]
Não faz muito sentido adicionar um product sem nome no sistema, nem um product com preço negativo.
Antes de adicionar o product, precisamos verificar se é um product válido, com nome e preço positivo,
e caso não seja válido voltamos para o formulário com mensagens de erro. Para fazermos isso, podemos
usar um componente do VRaptor: o Validator. Você pode recebê-lo no construtor do seu Controller, e
usá-lo da seguinte maneira:
[java h=9,10,11,12,13]
@Resource
public class ProductsController {
	public ProductsController(ProductDao dao, Result result, Validator validator) {
		//...
		this.validator = validator;
	}
	
	public void adiciona(Product product) {
		validator.checking(new Validations() {{
			that(!product.getNome().isEmpty(), "product.nome", "nome.vazio");
			that(product.getPreco() > 0, "product.nome", "preco.invalido");
		}});
		validator.onErrorUse(Results.page()).of(ProductsController.class).form();
		
		dao.adiciona(product);
		result.use(Results.logic()).redirectTo(ProductsController.class).lista();
	}
}
[/java]

Podemos ler as validações da seguinte maneira: ::Valide que o nome do product não é vazio e
que o preço do product é maior que zero. Se acontecer um erro, use como resultado a página
do form do ProductsController::. Ou seja, se por exemplo o nome do product for vazio, vai
ser adicionada a mensagem de erro para o campo "product.nome", com a mensagem "nome.vazio"
internacionalizada. Se acontecer algum erro, o sistema vai voltar pra página do formulário,
com os campos preenchidos e com mensagens de erro que podem ser acessadas da seguinte maneira:

[xml]
<c:forEach var="error" items="${errors}">
	${error.category}  ${error.message}<br />
</c:forEach>
[/xml]

Mais informações sobre o Validator no capítulo de Validações.

Com o que foi visto até agora você já consegue fazer 90% da sua aplicação! As próximas sessões
desse tutorial mostram a solução para alguns problemas frequentes que estão nos outros 10% da
sua aplicação.

[section Usando o Hibernate para guardar os Products]

Agora vamos fazer uma implementação de verdade do ProductDao, usando o Hibernate para
persistir os products. Para isso nosso ProductDao precisa de uma Session. Como o VRaptor
usa injeção de dependências, basta receber uma Session no construtor!

[java]
@Component
public class ProductDao {
	
	private Session session;
	
	public ProductDao(Session session) {
		this.session = session;
	}

	public void adiciona(Product product) {
		session.save(product);
	}
	//...
}
[/java]

Mas peraí, para o VRaptor precisa saber como criar essa Session, e eu não posso simplesmente
colocar um @Component na Session pois é uma classe do Hibernate! Para isso existe a interface
ComponentFactory, que você pode usar pra criar uma Session. Mais informações de como fazer
ComponentFactories no capítulo de Componentes. Você pode ainda usar os ComponentFactories que
já estão disponíveis para isso no VRaptor, como mostra o capítulo de Utils.

[section Controlando transações: Interceptors]
Muitas vezes queremos interceptar todas as requisições (ou uma parte delas) e executar alguma
lógica, como acontece com o controle de transações. Para isso existem os Interceptor's no
VRaptor. Saiba mais sobre eles no capítulo de Interceptors. Existe um TransactionInterceptor
já implementado no VRaptor, saiba como usá-lo no capítulo de Utils.

[section Carrinho de compras: Componentes na sessão]
Se quisermos criar um carrinho de compras no nosso sistema, precisamos de alguma forma manter os
itens do carrinho na Sessão do usuário. Para fazer isso, podemos criar um componente que está no
escopo de sessão, ou seja, ele vai ser único na sessão do usuário. Para isso basta criar um
componente anotado com @SessionScoped:
[java]
@Component
@SessionScoped
public class CarrinhoDeCompras {
	private List<Product> itens = new ArrayList<Product>();
	
	public List<Product> getTodosOsItens() {
		return itens;
	}
	
	public void adicionaItem(Product item) {
		itens.add(item);
	}
}
[/java]

Como esse carrinho de compras é um componente, podemos recebê-lo no construtor do controller que
vai cuidar do carrinho de compras:

[java]
@Resource
public class CarrinhoController {

	public CarrinhoController(CarrinhoDeCompras carrinho) {
		this.carrinho = carrinho;
	}

	public void adiciona(Product product) {
		carrinho.adicionaItem(product);
	}
	
	public List<Product> listaItens() {
		return carrinho.getTodosOsItens();
	}
}
[/java]

Além do escopo de sessão existe o escopo de Aplicação com a anotação @ApplicationScoped.
Os componentes anotados com @ApplicationScoped serão criados apenas uma vez em toda a aplicação. 

[section Um pouco de REST]

Seguindo a idéia REST de que %%URI%%s devem identificar recursos na rede para então podermos
fazer valer as diversas vantagens estruturais que o protocolo HTTP nos proporciona, 
note o quão simples fica mapear os diversos métodos HTTP para a mesma URI, e com
isso invocar diferentes métodos, por exemplo queremos usar as seguintes URIs para o
cadastro de products:

[code]
	GET /products - lista todos os products
	POST /products - adiciona um product
	GET /products/{id} - visualiza o product com o id passado
	PUT /products/{id} - atualiza as informações do product com o id passado
	DELETE /products/{id} - remove o product com o id passado
[/code]

Para criar esse comportamento REST no VRaptor podemos usar as anotações @Path
- que muda qual é a uri que vai acessar o determinado método, e as anotações
com os nomes dos métodos HTTP @Get, @Post, @Delete, @Put, que indicam que o método
anotado só pode ser acessado se a requisição estiver com o método HTTP indicado.
Então uma versão REST do nosso ProductsController seria:

[java]
public class ProductsController {
	//...
	
	@Get
	@Path("/products")
	public List<Product> lista() {...}
	
	@Post
	@Path("/products")
	public void adiciona(Product product) {...}

	@Get
	@Path("/products/{product.id}")
	public void visualiza(Product product) {...}
	
	@Put
	@Path("/products/{product.id}")
	public void atualiza(Product product) {...}
	
	@Delete
	@Path("/products/{product.id}")
	public void remove(Product product) {...}
	
}
[/java]

Note que podemos receber parâmetros nas URIs. Por exemplo se chamarmos a URI
**GET /products/5**, o método visualiza será invocado, e o parâmetro product vai
ter o id populado com 5.

Mais informações sobre isso no capítulo de Resources-REST.

[section Arquivo de mensagens]

Internacionalização (::i18n::) é um recurso poderoso, e que está presente em quase todos os frameworks 
Web hoje em dia. E não é diferente no VRaptor3. Com i18n podemos fazer com que nossa aplicação suporte
várias línguas (francês, português, espanhol, inglês, etc) de uma maneira que não nos cause muito esforço, 
bastando apenas fazermos a tradução das mensagens da nossa aplicação. 

Para isso é só criarmos um arquivo chamado ::messages.properties:: e disponibilizá-lo no classpath da 
nossa aplicação (%%WEB-INF/classes%%). O conteúdo desse arquivo são várias linhas compostas por um conjunto 
de chaves/valor, como por exemplo:

[code properties]
campo.nomeUsuario = Nome de Usuário
campo.senha = Senha
[/code]

Até então está fácil, mas e se quisermos criar esses arquivos para várias línguas, como por exemplo, inglês?
Simples, basta criarmos um outro arquivo properties chamado %%messages_en.properties%%. Repare no sufixo 
::_en:: no nome do arquivo. Isso indica que quando o usuário acessar sua aplicação através de uma máquina 
configurada com locale em inglês as mensagens desse arquivo serão utilizadas. O conteúdo desse arquivo então ficaria:

[code properties]
campo.nomeUsuario = Username
campo.senha = Password
[/code]

Repare que as chaves são mantidas, mudando apenas o valor para a língua escolhida.

Para usar essas mensagens em seus arquivos JSP, você pode utilizar a JSTL. Dessa forma, o código ficaria:

[code]
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
<html>
	<body>
		<fmt:message key="campo.usuario" /> <input name="usuario.nomeUsuario" />
		
		<br />
		
		<fmt:message key="campo.senha" /> <input type="password" name="usuario.senha" />
		
		<input type="submit" />
	</body>
</html>
[/code]
